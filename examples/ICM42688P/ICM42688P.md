``` C++

/* ============== accgyro_icm42605.c =================*/

static bool icm42605DeviceDetect(busDevice_t * dev)
{
    uint8_t tmp;
    uint8_t attemptsRemaining = 5;

    busSetSpeed(dev, BUS_SPEED_INITIALIZATION);

    busWrite(dev, ICM42605_RA_PWR_MGMT0, 0x00);

    do {
        delay(150);

        busRead(dev, MPU_RA_WHO_AM_I, &tmp);

        switch (tmp) {
            /* ICM42605 and ICM42688P share the register structure*/
            case ICM42605_WHO_AM_I_CONST:
                is42688P = false;
                return true;
            case ICM42688P_WHO_AM_I_CONST:
                is42688P = true;
                return true;

            default:
                // Retry detection
                break;
        }
    } while (attemptsRemaining--);

    return false;
}

/* ============== bus.h =================*/

typedef struct busDevice_s {
    const busDeviceDescriptor_t * descriptorPtr;
    busType_e busType;              // Copy of busType to avoid additional pointer dereferencing
    uint32_t flags;                 // Copy of flags
    uint32_t param;                 // Copy of param
    union {
#ifdef USE_SPI
        struct {
            SPIDevice spiBus;       // SPI bus ID
            IO_t csnPin;            // IO for CS# pin
        } spi;
#endif
#ifdef USE_I2C
        struct {
            I2CDevice i2cBus;       // I2C bus ID
            uint8_t address;        // I2C bus device address
        } i2c;
#endif
    } busdev;
    IO_t irqPin;                    // Device IRQ pin. Bus system will only assign IO_t object to this var. Initialization is up to device driver
    uint32_t * scratchpad;          // Memory where device driver can store persistent data. Zeroed out when initializing the device
                                    // for the first time. Useful when once device is shared between several sensors
                                    // (like MPU/ICM acc-gyro sensors)
} busDevice_t;

/* ============== bus.c =================*/

bool busWrite(const busDevice_t * dev, uint8_t reg, uint8_t data)
{
    if (dev->flags & DEVFLAGS_USE_RAW_REGISTERS) {
        return spiBusWriteRegister( dev, reg, data );
    } else {
        return spiBusWriteRegister( dev, reg & 0x7F, data );
    }
}

bool busRead(const busDevice_t * dev, uint8_t reg, uint8_t * data)
{
    if (dev->flags & DEVFLAGS_USE_RAW_REGISTERS) {
        return spiBusReadRegister(dev, reg, data);
    } else {
        return spiBusReadRegister(dev, reg | 0x80, data);
    }
}

/* ============== bus_busdev_spi.c =================*/

bool spiBusWriteRegister(const busDevice_t * dev, uint8_t reg, uint8_t data)
{
    SPI_TypeDef * instance = spiInstanceByDevice(dev->busdev.spi.spiBus);

    if (!(dev->flags & DEVFLAGS_USE_MANUAL_DEVICE_SELECT)) {
        spiBusSelectDevice(dev);
    }

    spiTransferByte(instance, reg);
    spiTransferByte(instance, data);

    if (!(dev->flags & DEVFLAGS_USE_MANUAL_DEVICE_SELECT)) {
        spiBusDeselectDevice(dev);
    }

    return true;
}

bool spiBusReadRegister(const busDevice_t * dev, uint8_t reg, uint8_t * data)
{
    SPI_TypeDef * instance = spiInstanceByDevice(dev->busdev.spi.spiBus);

    if (!(dev->flags & DEVFLAGS_USE_MANUAL_DEVICE_SELECT)) {
        spiBusSelectDevice(dev);
    }

    spiTransferByte(instance, reg);
    spiTransfer(instance, data, NULL, 1);

    if (!(dev->flags & DEVFLAGS_USE_MANUAL_DEVICE_SELECT)) {
        spiBusDeselectDevice(dev);
    }

    return true;
}

/* ============== bus_spi_hal_ll.c =================*/

uint8_t spiTransferByte(SPI_TypeDef *instance, uint8_t txByte)
{
    uint8_t value = 0xFF;
    if (!spiTransfer(instance, &value, &txByte, 1)) {
        return 0xFF;
    }
    return value;
}

bool spiTransfer(SPI_TypeDef *instance, uint8_t *rxData, const uint8_t *txData, int len)
{
#if defined(STM32H7)
    LL_SPI_SetTransferSize(instance, len);
    LL_SPI_Enable(instance);
    LL_SPI_StartMasterTransfer(instance);
    while (len) {
        int spiTimeout = 1000;
        while(!LL_SPI_IsActiveFlag_TXP(instance)) {
            if ((spiTimeout--) == 0) {
                spiTimeoutUserCallback(instance);
                return false;
            }
        }
        uint8_t b = txData ? *(txData++) : 0xFF;
        LL_SPI_TransmitData8(instance, b);

        spiTimeout = 1000;
        while (!LL_SPI_IsActiveFlag_RXP(instance)) {
            if ((spiTimeout--) == 0) {
                spiTimeoutUserCallback(instance);
                return false;
            }
        }
        b = LL_SPI_ReceiveData8(instance);
        if (rxData) {
            *(rxData++) = b;
        }
        --len;
    }
    while (!LL_SPI_IsActiveFlag_EOT(instance));
    LL_SPI_ClearFlag_TXTF(instance);
    LL_SPI_Disable(instance);
#else
    SET_BIT(instance->CR2, SPI_RXFIFO_THRESHOLD);

    while (len) {
        int spiTimeout = 1000;
        while (!LL_SPI_IsActiveFlag_TXE(instance)) {
            if ((spiTimeout--) == 0) {
                spiTimeoutUserCallback(instance);
                return false;
            }
        }
        uint8_t b = txData ? *(txData++) : 0xFF;
        LL_SPI_TransmitData8(instance, b);

        spiTimeout = 1000;
        while (!LL_SPI_IsActiveFlag_RXNE(instance)) {
            if ((spiTimeout--) == 0) {
                spiTimeoutUserCallback(instance);
                return false;
            }
        }
        b = LL_SPI_ReceiveData8(instance);
        if (rxData) {
            *(rxData++) = b;
        }
        --len;
    }
#endif

    return true;
}

```